{
  "name": "buffercursor",
  "version": "0.0.8",
  "author": {
    "name": "Timothy J Fontaine",
    "email": "tjfontaine@gmail.com",
    "url": "http://atxconsulting.com"
  },
  "description": "A simple way to traverse a Buffer like a cursor, updating position along the way",
  "keywords": [
    "buffer",
    "cursor",
    "stream"
  ],
  "homepage": "http://github.com/tjfontaine/node-buffercursor",
  "bugs": {
    "url": "http://github.com/tjfontaine/node-buffercursor/issues"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/tjfontaine/node-buffercursor.git"
  },
  "main": "buffercursor.js",
  "engines": {
    "node": ">= 0.5.0"
  },
  "readme": "BufferCursor\n============\n\nThis is a simple module that allows you to traverse a Buffer iteratively. You\ncan read and write different types and the cursor's position will update with\nthe proper size, which you can see through `.tell()` you can also\n`.seek()`\n\n```javascript\nvar bc = new BufferCursor(buffer);\nbc.readUInt16BE();\nbc.readUInt8();\nbc.readUInt32BE();\nconsole.log(bc.tell());\n```\n\nWill output `7`\n\nMethods\n-------\n\nFor the most part `BufferCursor` and `Buffer` share the same methods, there's\njust a slight alteration in method signature, none of the methods take an\noffset.\n\nSo `.readUInt16LE(10)` in `Buffer` is equivalent to `bs.seek(10); bs.readUInt16LE();`\n\nAll `read[U]Int` and `write[U]Int` methods are reproduced, as are `toString`,\n`write`, `fill`, and `slice`. All of these methods will move the cursor through\nthe stream and do not take an offset parameter, where an `end` parameter would\nnormaly be used, here you supply a `length`.\n\nThe following are additional methods:\n\n * `seek(value)` -- Seek to an arbitrary position in the stream\n * `tell()` -- Return the current location in the stream\n * `eof()` -- Return true if at the end of the stream\n * `toByteArray([method])` -- This is a special helper method which will return\nthe *entire* stream (i.e. from the start) as an array of numbers.\n  - By default it will use `readUInt8` but you can pass in any\n`read[U]Int[8,16,32][LE,BE]` to change what the array is made of\n\nProperties\n----------\n\n * `.buffer` -- Access to the raw buffer\n * `.length` -- The size of the buffer\n",
  "readmeFilename": "README.md",
  "_id": "buffercursor@0.0.8",
  "_from": "buffercursor@>=0.0.3"
}
